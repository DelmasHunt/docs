---
Title: Tickets
---

The following provides a detailed high level overview about tickets and how their attributes impact orchestrators including but not limited to:

- What are tickets and how do they work
- How adjusting orchestrator attributes affecting tickets impact orchestator payouts
- How orchestrator behavior changes with incoming tickets

***Related documentation*** [Earnings](https://docs.livepeer.org/video-miners/core-concepts/earnings) and [Payments](https://docs.livepeer.org/video-miners/core-concepts/payments).

## What is a ticket?

Broadcasters using the Livepeer network attach a “ticket” to each segment of a video they want transcoded. A ticket can be thought of as a form of work completed for a given video stream a broadcaster is emitting to the Livepeer network.  The final number of tickets associated with a given stream is a product of the fees proposed by the orchestrator for doing the work and the total length of the video processed.

A ticket is comprised of the following attributes:

- **recipient**: ETH address of recipient (orchestrator completing transcoding work)
- **faceValue**: The ETH value of the ticket payable to the recipient (orchestrator) if the ticket wins
- **winProb**: The probability of the ticket winning (number between 0 and 2^256
 - 1)
- **recipientRandHash**: Hashed commitment to a random number recipientRand generated by the recipient
- **senderNonce**: Random nonce generated by the broadcaster indicating the ticket is unique.
- **auxData**: Additional data associated with the ticket

Each ticket upon transmission from broadcaster to orchestrator is treated as a “micropayment” worth the expected value of the ticket (calculated as: face value multiplied by the win probability of the ticket).

## How Winning Tickets Are Picked

Picking tickets isn’t as simple as it might seem, we use an implementation based on [probabilistic micropayments](https://medium.com/livepeer-blog/streamflow-probabilistic-micropayments-f3a647672462).  At a high level, each ticket could be thought of as a “lottery” ticket of sorts.  But the raw implementation is a bit more complex than it might seem.

Orchestrators can set a configuration value called ticket expected value or “EV” which defines the value of work an orchestrator is willing to do before requiring a ticket.  By default this value is set to 1000 gwei, which translates to an orchestrator willing to complete 1000 gwei worth of transcoding (based on their pixel pricing configuration) before requiring a ticket.

Winning tickets are selected based on a ticket’s win probability (winProb) and a random value produced by hashing the broadcaster’s random number with a random number from the orchestrator linked to the commitment included in the ticket (recipientHash).  This process is completed at the end of each “round” on the Livepeer network.

## What Happens After I “Win”

If an orchestrator receives a winning ticket, the ticket can submit the ticket along with their recipientRandomHash to a smart contract which will verify the hash and attest that the ticket indeed won.  Given a pair of broadcaster and orchestrator (payor and payee) neither party can rig the system as the random value used to select winning ticket can only be seen by one party during the process of generating the ticket as the payee is forced to commit it’s random value prior to seeing the payer’s random number.

## How Often *Should* I win

Although each “win” is awarded randomly, the probabilistic in “probabilistic micropayments” ensures that even with adverse impact from factors like gas prices or fluctuation in network activity - at a high level payments follow a linear distribution trend.

## Creating and Redeeming Tickets

Assuming that the orchestrator and broadcaster have connected prior and completed the initial handshake.  

**Every new ticket T (emanating from a broadcaster) will result in the following steps completed by the broadcaster:**

1. Append recipientRandHash to T.
2. Append corresponding recipient, winProb and faceValue to T.
3. Generate senderNonce and append to T.
4. Send the ticket, associated signature and recipientSeed to the orchestrator.

**The orchestrator will receive each of these tickets and then complete the following steps:**

1. Compute the recipientRandHash by hashing recipientSecret AND recipientSeed
2. check the recipientRandHash
    1. if this fails, the ticket is rejected
3. Check that the recipientAddress matches the current orchestrator addresss
4. Check that the ticket has a valid signature and corresponds to the broadcaster address
5. Assert that the random identifier assigned to the ticket is truly random

The above process is loosely how the orchestrator keeps track of tickets flowing from various broadcasters and associated metrics are derived by counting these processes.

**If an orchestrator wins a ticket the following process begins:**

1. Submit the transaction (depending on orchestrator config this may be automatic) to the [TicketBroker smart contract](https://etherscan.io/address/0x58b6a8a3302369daec383334672404ee733ab239) with the below attributes included.
    - Ticket T
    - recipientRand
    - Broadcaster Signature
2. Assert that T has not already been identified or redeemed.
3. Assert that hashing recipientRand is equal to recipientRandHash
4. Recover the broadcaster payer address
5. Assert that the broadcaster has penalty collateral in escrow.
6. Hash the transaction against recipientRand and compare against winProb to see if the ticket actually indeed won
7. If the broadcaster’s deposit is less than faceValue of T, consume the broadcaster’s collateral escrow funds (proportionally relative to faceValue of T) to the orchestrator.  Otherwise, just transfer the faceValue of T.
8. Mark ticket as identified AND redeemed.
